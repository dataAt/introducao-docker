[
["introducao.html", "1 Introdu√ß√£o 1.1 Por que Docker ? 1.2 Virtualiza√ß√£o", " 1 Introdu√ß√£o Desde seu surgimento o Docker tem ganhado cada vez mais espa√ßo nos servidores mundo a fora, suas caracteristicas f√°ceis de entender e simples de aplicar permitem sua utiliza√ß√£o nos mais variados cen√°rios. No √¢mbito cient√≠fico, o Docker vem sendo utilizado cada vez mais para a garantia da reprodutibilidade, uma vez que, suas caracter√≠sticas de isolamento de ambiente munidos da efici√™ncia, permitem a f√°cil distribui√ß√£o de ambientes j√° configurados para a execu√ß√£o dos trabalhos desenvolvidos, como @Boettiger2014 e @Schommer2014 apresentam. O Instituto Nacional de Pesquisas Espaciais (INPE), por exemplo, faz a utiliza√ß√£o do Docker, para tornar os sistemas cient√≠ficos computacionais desenvolvidos mais acess√≠vel para todos que queiram fazer sua utiliza√ß√£o de uma forma simples e r√°pida. Neste contexto, este material busca realizar uma introdu√ß√£o do Docker e os principais conceitos envolvidos na utiliza√ß√£o desta ferramenta. A cria√ß√£o deste material foi feita para ajudar a todos que queiram come√ßar a utilizar o Docker em seu dia-a-dia üòÑ. 1.1 Por que Docker ? A resposta para esta pergunta pode ter v√°rias respostas, uma vez que, a depender do contexto onde voc√™ est√° inserido, o Docker pode trazer muitos benef√≠cios, vou colocar aqui em um contexto mais relacionado ao desenvolvimento de aplica√ß√µes. Ent√£o, vamos come√ßar imaginando que voc√™ √© um desenvolvedor Python, que est√° trabalhando em v√°rios projetos. O primeiro projeto que voc√™ est√° trabalhando, est√° relacionado ao desenvolvimento de uma aplica√ß√£o web e para isso, tem utilizado o PostgreSQL e Django, para realizar o desenvolvimento, j√° o segundo projeto, est√° ligado ao processamento de dados geoespaciais e voc√™ utilizou o GDAL e o numpy. Tudo bem at√© aqui ? √â um cen√°rio simples de imaginar. Bem, como voc√™ desenvolve na mesma m√°quina e √© um desenvolvedor Python com bastante experi√™ncia em projetos, entende que, as depend√™ncias do projeto web n√£o podem interferir no projeto de processamento de geodados. Para resolver este problema voc√™ cria ambientes virtuais dentro do Python, com isso, voc√™ consegue separar os projetos e garantir que, as bibliotecas e depend√™ncias de um projeto em momento algum ir√£o interferir em outro projeto, al√©m de permitir que voc√™ controle melhor as depend√™ncias de cada projeto. Ent√£o, voc√™ finaliza os dois projetos e eles devem ser distribuidos para todos e √© aqui que os problemas come√ßam, durante a instala√ß√£o das depend√™ncias, voc√™ percebeu que, dependendo da vers√£o do S.O, a biblioteca que voc√™ utilizou para se conectar ao PostgreSQL, SQLAlchemy, apresenta problemas quando tenta ser instalado com o pip, o que faz a instala√ß√£o dos requirements.txt dar problemas. E ainda, no projeto de processamento, uma das depend√™ncias, o GDAL, que facilita a leitura de dados espaciais tamb√©m tem o mesmo problema, dependendo da plataforma, ele tem problemas para instalar. Ops! Os projetos est√£o prontos, por√©m as depend√™ncias podem dificultar a utiliza√ß√£o e implanta√ß√£o deles. √â aqui que entra o Docker, voc√™ vai criar duas imagens (Ser√£o apresentadas mais para frente no material) com todo o seu projeto e o Docker vai garantir que, independende da plataforma ou do OS utilizado, eles v√£o funcionar. Veja que interessante! Com o Docker, o famoso ‚ÄúNa minha m√°quina funciona‚Äù deixa de existir, e o projeto vai funcionar em todas as plataformas. Este √© um pequeno exemplo de o porque utilizar Docker, outros poderiam ser colocados aqui. Esta mini hist√≥ria foi inserida apenas para voc√™ entender que o Docker pode te ajudar em problemas do dia-a-dia. 1.2 Virtualiza√ß√£o Bem, para come√ßarmos a falar de Docker, vamos antes falar um pouco sobre virtualiza√ß√£o, um conceito fundamental no entendimento do funcionamento do Docker. Virtualiza√ß√£o √© o processo de criar ambientes virtuais isolados. Existem duas formas de prover tais ambientes (@Chung2016), sendo elas, as baseadas em containers ou hypervisors (@Morabito2015). Na virtualiza√ß√£o baseada em hypervisor √© criado a representa√ß√£o virtual de um hardware (@Firesmith), tamb√©m chamada de MV, que √© controlada por um hypervisor, sendo este uma camada que faz o interm√©dio de recursos entre o ambiente virtual criado e o hardware, e neste ambiente virtual gerado, sistemas operacionais comuns podem ser executados. Esta representa√ß√£o de hardware √© completamente isolada da m√°quina onde est√° sendo alocada (@Morabito2015), o que permite, por exemplo, que uma m√°quina que gera uma MV seja Linux, e o ambiente instalado dentro da MV seja Windows (@Morabito2015). O ponto de troca aqui √© que, o sistema operacional ter√° de ser instalado por completo dentro da MV (@Morabito2015). A Figura abaixo apresenta a arquitetura das virtualiza√ß√µes hypervisor. Veja na Figura que, acima do hypervisor, que gera as representa√ß√µes virtuais de ambientes de execu√ß√£o, s√£o instalados todo o sistema operacional e ent√£o, as aplica√ß√µes podem come√ßar a ser executadas. Por outro lado existem as t√©cnicas de virtualiza√ß√£o baseadas em containers, que s√£o executadas a n√≠vel de sistema operacional (@Firesmith), que criam ambientes isolados com o compartilhamento de arquivos, bibliotecas e o kernel do sistema base onde est√° sendo executado. Estes ambientes isolados s√£o utilizados para a execu√ß√£o de processos e aplica√ß√µes. √â neste tipo de virtualiza√ß√£o que o Docker se encaixa. Na Figura abaixo √© poss√≠vel visualizar como este m√©todo de virtualiza√ß√£o funciona. Veja que, n√£o h√° representa√ß√£o de v√°rias m√°quinas sendo criadas e sim de aplica√ß√µes que est√£o sendo executadas, j√° que, neste m√©todo de virtualiza√ß√£o, cada um dos ambientes criados, tamb√©m chamados de containers, normalmente executam um √∫nico processo que pode, por exemplo, ser uma aplica√ß√£o web ou mesmo um processo bash, que disponibiliza um terminal ao utilizador. "],
["docker.html", "2 Docker üê≥ 2.1 Instala√ß√£o 2.2 Containers 2.3 Imagens de containers 2.4 Arquitetura 2.5 Administrando containers", " 2 Docker üê≥ Docker √© uma plataforma para o gerenciamento de containers (@Schommer2014), que ajuda desenvolvedores e administradores de sistemas a desenvolver, distribuir, implantar e executar aplica√ß√µes em ambientes isolados, sem problemas com depend√™ncias do ambiente ou configura√ß√µes atrav√©s de Linux Containers (LXC) (@Schommer2014). Ao utilizar o Docker, todos os problemas relacionados a instala√ß√£o, configura√ß√£o e solu√ß√£o de problemas relacionados a conflitos de depend√™ncias de um sistema s√£o facilmente resolvidos. Atualmente o Docker vem sendo aplamente utilizado por sua facilidade de uso e baixa utiliza√ß√£o de recursos computacionais para a implanta√ß√£o de sistemas e execu√ß√£o de algoritmos. Todo o funcionamento do Docker √© baseado em uma comunica√ß√£o cliente-servidor, onde o cliente, atrav√©s de uma API Rest envia comandos para o docker-daemon, que por sua vez representa o gerenciador de containers que realiza todas as opera√ß√µes e verifica√ß√µes necess√°rias para o funcionamento correto e simples do Docker. Esta estrutura √© resumida na Figura abaixo. A forma como fazemos a utiliza√ß√£o da estrutura acima pode variar, j√° que se trata de uma API Rest, b√°sicamente, qualquer linguagem de programa√ß√£o que suporte a comunica√ß√£o atrav√©s de protocolos de rede como HTTP conseguem se comunicar e interagir com o docker-daemon. Veja a Figura abaixo. Na Figura acima √© poss√≠vel entender como o processo de comunica√ß√£o e intera√ß√£o com o docker-daemon funciona. O Cliente envia comandos atrav√©s da API Rest, sendo que para esta j√° existem diversas ferramentas que consomem e facilitam o processo, como √© o caso do pr√≥prio Docker CLI, que √© uma ferramenta de linha de comando distribuida nas instala√ß√µes padr√£o do Docker. O Servidor recebe as requisi√ß√µes e faz os tratamentos e opera√ß√µes equivalentes aos pedidos. Este tipo de estrutura permite que, atrav√©s de uma m√°quina seja feito o gerenciamento de v√°rios servidores Docker, sem contar que, por ser uma API Rest, aplica√ß√µes podem fazer intera√ß√µes com o servidor, o que facilita ainda mais a cria√ß√£o e disponibiliza√ß√£o de ferramentas para o gerenciamento de containers atrav√©s do Docker. O ambiente do Docker, que como citado, √© gerenciado pelo docker-daemon √© constituido por tr√™s componentes principais (@Chung2016), sendo eles, Docker images e Dockerfiles, Docker registry e Docker containers. Cada um desses explicados nas subse√ß√µes seguintes. 2.1 Instala√ß√£o Agora com a vis√£o geral de funcionamento do Docker, vamos fazer a instala√ß√£o dele para come√ßarmos a fazer sua utiliza√ß√£o e entender os conceitos na pr√°tica! Por uma quest√£o de facilidade, recomenda-se a utiliza√ß√£o de um ambiente Linux. Os passos abaixo, apresentam a instala√ß√£o do Docker no Linux Ubuntu (16.04 ou superior). $ curl -fsSL https://get.docker.com -o get-docker.sh $ sudo sh get-docker.sh Caso voc√™ queira permitir a execu√ß√£o do Docker para usu√°rios que n√£o sejam root voc√™ pode executar o comando abaixo $ sudo usermod -aG docker seu-usuario Caso voc√™ n√£o execute o comando de permiss√£o acima, todos os seus comandos do Docker dever√£o ser executados pelo root ou junto ao comando sudo. Feito! A instala√ß√£o do Docker j√° est√° pronta e funcionando na sua m√°quina, para testar execute o comando docker -v, o retorno deve ser algo parecido com isto Docker version 18.09.7, build 2d0083d O comando docker e todos os seus par√¢metros representam a ferramenta Docker CLI, que foi citada anteriormente e j√° vem instalada na distribui√ß√£o padr√£o do Docker. Se voc√™ estiver utilizado uma outra plataforma que n√£o a apresentada acima, voc√™ pode consultar o site do Docker (https://docs.docker.com/install/) para verificar como prosseguir com a instala√ß√£o. 2.2 Containers Containers s√£o inst√¢ncias de Imagens Docker que est√£o sendo executadas em ambientes isolados, sendo que, nestes ambientes h√° todos os recursos necess√°rios para a execu√ß√£o dos processos os quais foram definidos para os containers. Por exemplo, quando voc√™ quiser executar um container com o Postgres, ao realizar a execu√ß√£o, dentro do container j√° estar√° todas as bibliotecas necess√°rias para a execu√ß√£o do Postgres, inclusive os bin√°rios do banco propriamente dito. 2.3 Imagens de containers Como citado anteriormente, um container representa uma imagem Docker que est√° sendo executada. As imagens Docker, por sua vez, representam arquivos execut√°veis que possuem todo o descritivo de arquivos e processos que devem ser feitos no momento em que s√£o executadas para a gera√ß√£o de um container. Com isto, as imagens Docker garantem que, todos os containers gerados atrav√©s da mesma imagem sejam padronizados, tendo uma mesma estrutura. 2.3.1 Criando imagens A cria√ß√£o de imagens Docker √© feita atrav√©s da utiliza√ß√£o de arquivos Dockerfiles, estes que descrevem qual ser√° a estrutura das imagens e suas opera√ß√µes. Dentro do Dockerfile existem diversas instru√ß√µes para ditar cada caracteristica que deve ser empregada na imagem que est√° sendo gerada. Para voc√™ entender melhor, vamos criar um exemplo de uma imagem Docker que gera um container que executa um script Python. Vamos come√ßar criando o script Python, fazemos isto utilizando o comando abaixo echo &quot;print(&#39;Oi! Esta √© minha primeira imagem Docker! E ela funciona!&#39;)&quot; &gt; ola.py Com o script criado, vamos criar um arquivo com o nome Dockerfile, dentro deste arquivo, vamos inserir o seguinte conte√∫do. N√£o se preocupe se voc√™ n√£o entender agora, cada uma das partes deste arquivo ser√° explicada. FROM python:3 COPY ola.py ./ CMD [ &quot;./ola.py&quot; ] ENTRYPOINT [ &quot;python&quot; ] Ao finalizar a edi√ß√£o do arquivo, v√° at√© o diret√≥rio onde o arquivo est√° criado, e execute o comando docker build. docker build -t &quot;minha_primeira_imagem:1.0&quot; . Com este comando a sua imagem Docker ser√° criada. Para verificar se ela realmente foi criada execute o comando docker images, que lista todas as imagens dispon√≠veis para voc√™ utilizar. Ao digitar este comando voc√™ perceber√° que h√° uma imagem com REPOSITORY de nome minha_primeira_imagem. Para utilizar a imagem criada para gerar um container, vamos fazer a execu√ß√£o da imagem docker run minha_primeira_imagem:1.0 Caso queira apagar a imagem que criamos, utilize o comando docker rmi (docker rmi minha_primeira_imagem:1.0) 2.3.1.1 Entendendo o Dockerfile Anteriormente foi visto um simples Dockerfile, que criou uma imagem para a execu√ß√£o de um script Python, vamos analisa-lo para entender o que foi feito. Inicialmente no arquivo foi importado uma imagem com nome python:3, isto √© feito com o comando FROM. Ou seja, sua imagem foi criada com base em uma outra imagem, esta que j√° possuia o Python 3 instalado. Ap√≥s a defini√ß√£o da imagem base, foi feito uma c√≥pia do script para dentro do container, atrav√©s do comando COPY. Por fim, os comandos CMD e ENTRYPOINT foram executados, e estes representam partes muito importantes de um Dockerfile, isto porque, normalmente um container √© criado para executar um √∫nico processo, podendo este ser por exemplo, a inicializa√ß√£o de uma aplica√ß√£o, ou a execu√ß√£o de um script , como fizemos. A defini√ß√£o do processo que o container ir√° executar √© feita atrav√©s do comando ENTRYPOINT, ou seja, no nosso caso o processo principal ser√° uma execu√ß√£o python, e o comando CMD faz o aux√≠lio ao ENTRYPOINT j√° que, o CMD representam os par√¢metros que ser√£o passados para o ENTRYPOINY. Existem muitas outras instru√ß√µes que poderiam ser aplicadas neste Dockerfile, para saber mais sobre eles utilize a documenta√ß√£o do Docker (https://docs.docker.com/engine/reference/builder/). 2.3.1.2 Camadas de uma imagem O Docker trabalha utilizando um conceito de camadas, onde cada modifica√ß√£o realizada por comandos do Dockerfile cria uma camada que n√£o pode ser alterada, sendo poss√≠vel alterar somente a √∫ltima camada gerada. √â importante entender o conceitos de camadas para que, suas imagens n√£o fiquem grandes e com arquivos desnecess√°rios. Durante os testes de gera√ß√£o de imagens, ao executar o comando docker buid, v√°rias informa√ß√µes foram exibidas, cada uma daquelas informa√ß√µes representam as camadas que estavam sendo criadas na imagem gerada. Para entendermos melhor como as camadas funcionam, vamos criar um pequeno exemplo. Veja o seguinte Dockerfile. FROM ubuntu RUN apt update -y RUN apt install vim -y ENTRYPOINT [ &quot;bash&quot; ] Ao executar o comando docker build com o Dockerfile acima, a seguinte estrutura de camadas ser√° criada. Veja que, para cada comando foi criado uma camada, que por sua v√™z tem um peso. Das camadas 1 a 4 nada mais pode ser alterado. Por√©m h√° um pequeno problema, quando o comando apt update -y foi executado cache foi criado e certamente n√£o vai mais ser utilizado. O problema √© que este cache ficou em uma camada read-only e n√£o poder√° mais ser modificado. Se o comando para limpar o cache for utilizado, a camada onde o cache est√° ser√° copiada para o topo e ent√£o editada. Ou seja, mais uma camada foi criada, por√©m o cache ainda continua l√°. Para resolve reste problema √© preciso melhorar a forma como o Dockerfile foi criado, tentando executar tudo o que for poss√≠vel em uma √∫nica camada, por exemplo. FROM ubuntu RUN apt update -y &amp;&amp; apt install vim -y &amp;&amp; apt clean ENTRYPOINT [ &quot;bash&quot; ] Com o Dockerfile acima, somente tr√™s camadas ser√£o criadas, j√° que, toda a modifica√ß√£o para a instala√ß√£o do vim √© feita em uma √∫nica camada, que tem o cache removido. Com isto √© poss√≠vel perceber a necessidade de otimizar os Dockerfiles e evitar camadas desnecess√°rias que s√≥ ocupam espa√ßo Para saber mais formas de otimiza√ß√£o de Dockerfiles, consulte a documenta√ß√£o do Docker (https://docs.docker.com/develop/develop-images/dockerfile_best-practices/). 2.3.2 Aquisi√ß√£o de imagens Al√©m da cria√ß√£o de imagens √© poss√≠vel fazer a aquisi√ß√£o de imagens j√° criadas pela comunidade, ou mesmo distribu√≠da por algum instituto ou empresa com seus sistemas j√° configurados e prontos para a execu√ß√£o. Para isso o Docker Registry pode ser utilizado, este que √© um componente que est√° dentro da plataforma Docker e que facilita muito a sua utiliza√ß√£o. Estes componentes podem ser p√∫blicos e dispon√≠vel para todos, como o caso do Dockerhub ou privado, espec√≠fico para empresas e institutos, por exemplo. Por fazer parte da plataforma, o registry j√° est√° integrado ao funcionamento do docker-daemon. Vamos fazer alguns testes para entender. Utilize o comando docker images para listar as imagens que est√£o em sua m√°quina. Voc√™ provavelmente s√≥ ter√° a imagem criada anteriormente (Isso se voc√™ n√£o exclu√≠u ela). Vamos ent√£o tentar executar uma imagem que n√£o est√° na sua m√°quina. docker run centos:7 Mesmo voc√™ n√£o tendo a imagem nomeada centos:7 em sua m√°quina o comando est√° sendo executado, isso porque o docker-daemon, por padr√£o, ao n√£o encontrar em sua m√°quina verifica no registry p√∫blico Docker hub e verifica se tem uma imagem com o nome que voc√™ inseriu, caso tenha ele baixa para dai executar o comando inserido. Veja a Figura. Durante os passos da cria√ß√£o do Dockerfile essa feature foi utilizada, ao inserir a imagem de nome python:3 na instru√ß√£o FROM do Dockerfile, o docker-daemon verifica se h√° a imagem na m√°quina, como n√£o tinha ele baixou para ent√£o continuar a cria√ß√£o da imagem. 2.4 Arquitetura Com todos os componentes j√° conhecidos, h√° a possibilidade da expans√£o da vis√£o geral de toda a estrutura e funcionamento do Docker. Inicialmente haviamos definido somente a forma de comunica√ß√£o entre o cliente-servidor, por√©m agora com todos os conceitos que j√° vimos, vamos olhar como todo o ambiente Docker est√° integrado, para isto veja a Figura abaixo. √â poss√≠vel perceber toda a liga√ß√£o entre cada um dos componentes apresentados at√© aqui. Com isso estamos prontos para iniciar as atividades pr√°ticas com o Docker e o gerenciamento de containers. 2.5 Administrando containers Esta se√ß√£o apresenta exemplos para a administra√ß√£o de containers atrav√©s da utiliza√ß√£o do Docker CLI. 2.5.1 Criando containers Vamos come√ßar com exemplos das diferentes formas de cria√ß√£o de container. Come√ßando com a cria√ß√£o b√°sica de um container do Debian. docker create debian Depois de criar, utilize o comando docker ps -a para listar todos os containers criados. Quando voc√™ listar, vai ver v√°rias informa√ß√µes sobre o container criado, como por exemplo a imagem que ele utilizou, o ID, se h√° portas de rede abertas e o nome. Por padr√£o, n√£o √© necess√°rio definir o nome do container, mas √© recomendado que o fa√ßa, ent√£o vamos excluir o container criado e gerar um novo com um nome definido. # Exclu√≠ndo container docker rm ID_DO_CONTAINER_CRIADO # Criando um novo container de nome exemplo_debian docker create --name exemplo_debian debian Ao listar novamente todos os containers voc√™ vai ver que l√° est√° o novo container, com o nome que foi definido no comando anterior. O container ainda n√£o est√° sendo executado, uma vez que definimos que ele deveria apenas ser criado, vamos ent√£o executar ele com o comando docker start. docker start exemplo_debian Ele foi executado, para listar somente os containers que est√£o sendo executados, utilize o comando docker ps, sem qualquer outro par√¢metro. Sua listagem estar√° vazia j√° que o container do Debian est√° configurado para executar o comando bash, ent√£o, ao iniciarmos o container ele executou o comando e em seguida finalizou, se quisermos manter o container ligado, devemos definir que ele ter√° um terminal interativo, para isto no momento da cria√ß√£o, os par√¢metros -ti devem ser passados. Vamos l√° ent√£o, excluir o que haviamos criado e gerar ele novamente com os novos par√¢metros # Exclu√≠ndo container exemplo_debian docker rm exemplo_debian # Gerando um novo container que trabalha em segundo plano docker create -ti --name exemplo_debian debian # Executando o novo container criado docker start exemplo_debian Ao executar os comandos o novo container j√° estar√° sendo executado, para verificar, liste novamente os containers em execu√ß√£o. Vamos agora acessar o container criado, para isto usamos o comando docker attach, que recupera o bash do container caso ele n√£o esteja executando outro processo. docker attach exemplo_debian Em outros cen√°rios o bash pode n√£o estar dispon√≠vel, ent√£o ao inv√™s do docker attach pode ser utilizado o docker exec (https://docs.docker.com/engine/reference/commandline/exec/) Ao executar o comando, voc√™ j√° estar√° dentro do terminal do container criado. Como dito anteriormente, este ambiente √© isolado de sua m√°quina, ent√£o fa√ßa testes, navegue entre os diret√≥rios, para voc√™ ver que √© uma inst√¢ncia completamente isolada. Para sair do terminal e n√£o finalizar o container utilize os seguintes bot√µes de seu teclado: CTRL + p + q. Ao listar novamente os containers em execu√ß√£o, l√° estar√° ele sendo executado. Nos exemplos anteriores criavamos o container depois faziamos sua execu√ß√£o, por√©m podemos j√° criar um container e imediatamente realizar sua inicializa√ß√£o, para isto utilizamos o comando docker run, que recebe os mesmos par√¢metros que o docker create, com a diferen√ßa de que ele executa o container ap√≥s sua cria√ß√£o. docker run -ti --name exemplo_debian debian Executando o comando acima, o container ir√° iniciar e voc√™ j√° estar√° em seu bash. 2.5.2 Gerenciando as execu√ß√µes de um container Com os containers em execu√ß√£o, vamos entender quais s√£o os estados de um container e como podemos fazer a manipula√ß√£o desses. Ao criar um container com docker create o status dele √© CREATED e as modifica√ß√µes dessa estado s√£o feitos com os comandos na Tabela abaixo, junto aos comandos, h√° os estados que eles geram no container. Comando Estado gerado docker create CREATED docker run UP docker start UP docker stop EXITED docker restart UP docker pause UP (PAUSED) docker unpause UP Para entender cada um dos estados que estes comandos geram em um container vejamos a Tabela abaixo. Estado Descri√ß√£o CREATED Representa que o container foi criado, possui uma camada que pode ser escrita e est√° pronto para ser iniciado UP Indica que o container est√° em execu√ß√£o UP (PAUSED) Indica que o container est√° ‚Äúligado‚Äù por√©m sua execu√ß√£o est√° parada EXITED Indica que a execu√ß√£o do container foi finalizada Estes estados nos ajudam a entender o que est√° ocorrendo com os containers se est√£o trabalhando sem nenhum problema ou mesmo se est√£o ou n√£o sendo executados. 2.5.3 Visualizando status do container Al√©m do estado do container, em certos casos √© necess√°rio avaliar outras informa√ß√µes do container, a Tabela abaixo descreve comandos que podem ser √∫teis para a avalia√ß√£o e verifica√ß√£o dos containers. Comando Descri√ß√£o docker stats Exibe estat√≠sticas de utiliza√ß√£o de recursos feitas pelo container em tempo real docker top Exibe os processos que est√£o sendo executados no container docker logs Exibe os logs do container. A forma que os logs s√£o exibidas depende da forma como o servi√ßo que est√° sendo executado registrou os logs docker inspect Exibe informa√ß√µes gerais do container, no formato JSON 2.5.4 Gerenciamento de mem√≥ria e CPU Durante as verifica√ß√µes de estado e utiliza√ß√£o de um container, pode ser necess√°rio atribuir para ele limites de utiliza√ß√£o, isto para que o desempenho dos v√°rios containers que est√£o sendo executados n√£o seja prejudicado pela necessidade de uso de um √∫nico container. Quando n√£o √© atribuido limites de recursos a um container, se necess√°rio, ele pode consumir todos os recursos da m√°quina onde est√° sendo executado. Vamos come√ßar criando um container normalmente, como haviamos feito at√© aqui. docker run -ti --name debian_de_teste debian Agora, com a ajuda do comando docker inspect, vamos avaliar a quantidade de mem√≥ria configurada para uso deste container. docker inspect debian_de_teste | grep -i memory A sa√≠da do comando acima √© parecida com isto: &quot;Memory&quot;: 0, &quot;KernelMemory&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, O campo Memory est√° com valor 0, isto indica que, para este container n√£o h√° limita√ß√£o de uso de mem√≥ria, como citado anteriormente. Para resolver este problema, vamos excluir este container e gerar um novo com a limita√ß√£o de mem√≥ria. # Exclu√≠ndo container sem limite de mem√≥ria # -f Para excluir mesmo se o container estiver com estado UP docker rm -f debian_de_teste # Criando container com limite de 512 MB docker run -ti --name debian_de_teste --memory 512m debian Ap√≥s os comandos, caso eu execute novamente o docker inspect ser√° poss√≠vel visualizar a mudan√ßa no limite de mem√≥ria. docker inspect debian_de_teste | grep -i memory Sa√≠da: &quot;Memory&quot;: 536870912, &quot;KernelMemory&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: -1, &quot;MemorySwappiness&quot;: null, Com isso, o container n√£o vai consumir mais que 512 MB da m√°quina onde est√° sendo executado. Outra cen√°rio poss√≠vel para a mudan√ßa de quantidade de mem√≥ria √© quando o container j√° est√° funcionando e voc√™ precisa mudar seu limite de mem√≥ria. Isto pode ser feito atrav√©s do comando docker update. Vamos mudar a quantidade de mem√≥ria do container de testes que geramos acima. docker update --memory 256m debian_de_teste O comando docker update b√°sicamente recebe o par√¢metro que precisa ser alterado, o novo valor e o container id ou container name para fazer a mudan√ßa. Ao consultar novamente a quantidade de mem√≥ria, veremos que ela foi atualizada para 256 MB &quot;Memory&quot;: 268435456, &quot;KernelMemory&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: -1, &quot;MemorySwappiness&quot;: null, Al√©m da mem√≥ria pode ser necess√°rio limitar a quantidade de CPU que o container pode utilizar. Todos os principios apresentados na mudan√ßa de mem√≥ria podem ser aplicados aqui, ou seja, pode ser atribuido valores de limita√ß√£o na cria√ß√£o ou em containers j√° em execu√ß√£o, o ponto para a CPU √© que os valores atribuidos funcionam um pouco diferentes, vamos para a explica√ß√£o. Quando os valores de utiliza√ß√£o de CPU v√£o ser atribuidos, √© utilizado um conceito de propor√ß√£o, vamos para um exemplo, neste tr√™s containers ser√£o criados. docker run -ti --name debian_1 --cpu-shares 1024 debian docker run -ti --name debian_2 --cpu-shares 512 debian docker run -ti --name debian_3 --cpu-shares 512 debian O par√¢metro --cpu-shares √© quem define os valores de utiliza√ß√£o da CPU Lembre-se que, para sair do container sem fecha-lo utilize as teclas CTRL + p + q. Ap√≥s criar os tr√™s containers vamos entender o pensamento por tr√°s da proporcionalidade. O primeiro container possui 1024 cpu-shares e os outros dois containers criados possuem 512 cpu-shares cada. O segundo e o terceiro container criados, tem cada um 50% do valor atribuido para o primeiro container. Quando todos os valores atribuidos a cada container s√£o somados, chegamos em um valor de 2048. Sobre este valor, se aplicarmos uma proporcionalidade, √© poss√≠vel entender que o primeiro container possui 50% do valor total e os outros dois 25% cada um. Estes valores da proporcionalidade, s√£o exatamente as quantidades que cada um poder√° utilizar do 100% total de utiliza√ß√£o da CPU, assim, o primeiro poder√° utilizar at√© 50%, enquanto os outros dois poder√£o utilizar at√© 25% cada um. Lembrando que o comando docker update funciona da mesma forma como apresentado no controle de mem√≥ria, com a diferen√ßa de que o par√¢metro inserido para este caso ser√° o --cpu-shares. 2.5.5 Armazenamento Para finalizar este conte√∫do b√°sico sobre Docker, vamos tratar de algumas formas de armazenamento poss√≠veis nos containers. Existem tr√™s formas poss√≠veis de armazenamento em um container, cada uma dessas formas √© apresentada na Tabela abaixo. Tipo de armazenamento Descri√ß√£o Volumes S√£o formas de armazenamento que ficam registradas em lugares espec√≠ficos do sistema de arquivos da m√°quina que executa o Docker e todo seu controle √© feito pelo docker-daemon Bind mounts Podem ser armazenados em qualquer lugar do sistema de arquivos da m√°quina que executa o Docker e o docker n√£o faz seu gerenciamento tmpfs Sistema de arquivos tempor√°rios criados diretamente na mem√≥ria e n√£o s√£o salvos A escolha dentre essas possibilidades pode variar de acordo com seu cen√°rio de utiliza√ß√£o. N√£o deixe de consultar a documenta√ß√£o do Docker para dicar e formas de utiliza√ß√£o de cada uma dessas (https://docs.docker.com/storage/) Cada uma dessas formas listadas na Tabela anterior, indicam formas de criar mapeamentos de unidades e arquivos entre o container e a m√°quina onde o docker-daemon est√° sendo executado. Veja a Figura abaixo. Como √© poss√≠vel perceber na Figura acima, o mapeamento faz b√°sicamente com que os arquivos ou diret√≥rios do sistema de arquivos do container sejam armazenados em outros contextos que n√£o o do pr√≥prio container, tendo como formas de mapeamento, os itens listados na Tabela acima. Vamos focar aqui em apresentar os Volumes e os Bind mounts. Vamos come√ßar criando um container que possui um volume. docker run -ti -v /volume --name ubuntu_com_volume ubuntu Ao executar o comando e estar dentro do container v√° at√© o diret√≥rio raiz / e execute o comando ls, para listar os diret√≥rios. Na listagem voc√™ ver√° que h√° um diret√≥rio de nome volume, acesse ele e crie um arquivo qualquer. cd /volume &amp;&amp; &gt; arquivo_qualquer.txt Feito isto, vamos sair do container e verificar em qual local do disco o volume foi criado. Para sair do container n√£o esqueca de utilizar o CTRL + p + q, o que evita a finaliza√ß√£o do processo principal do container. Ap√≥s sair vamos verificar onde o volume foi criado com o aux√≠lio do comando docker inspect. docker inspect -f {{.Mounts}} ubuntu_com_volume O par√¢metro -f ajuda na filtragem do comando docker inspect. A sa√≠da do comando √© parecido com isto [{volume 3af1c580d4679973c86fbe7b6cdc755595a726f41aec7c8c59186f10885732fa /var/lib/docker/volumes/3af1c580d4679973c86fbe7b6cdc755595a726f41aec7c8c59186f10885732fa/_data /volume local true }] Veja que, ele indica onde o diret√≥rio /volume que foi montado dentro do container est√° na m√°quina local. Vamos ent√£o acessar este diret√≥rio e verificar seu conte√∫do. cd /var/lib/docker/volumes/3af1c580d4679973c86fbe7b6cdc755595a726f41aec7c8c59186f10885732fa/_data Ap√≥s mudar o diret√≥rio e listar seu conte√∫do, voc√™ provavelmente ver√° o arquivo que foi criado arquivo_qualquer.txt, isto ocorre j√° que, como foi explicado, os volumes permitem o mapeamento de arquivos e diret√≥rios que est√£o presentes no sistema de arquivos do container. Outra da forma de realizar o mesmo processo √© fazendo a utiliza√ß√£o de bind mounts que evita a cria√ß√£o de volumes e permite que o mapeamento seja feito diretamente entre um diret√≥rio/arquivo da m√°quina onde o docker-daemon √© executado e um diret√≥rio/arquivo do container. Para vermos isto na pr√°tica, vamos excluir o container de testes que criamos anteriormente e gerar um novo contendo esta forma de mapeamento. # Excluindo o container gerado anteriormente docker rm -f ubuntu_com_volume # Gerando container com bind mounts mkdir /arquivos_containers docker run -ti -v /arquivos_containers:/volume --name ubuntu_com_volume ubuntu Antes de criar o container foi necess√°rio criar um diret√≥rio, isto porque este ser√° vinculado diretamente com o /volume que est√° dentro do container, assim, todo o conte√∫do que foi criado l√°, estar√° sendo criado dentro deste diret√≥rio que foi gerado. Dentro do container, v√° at√© o diret√≥rio volume e crie um arquivo qualquer. cd /volume &amp;&amp; &gt; arquivo_qualquer_2.txt Agora saida do container e liste o diret√≥rio /arquivos_containers, voc√™ vai perceber que o arquivo criado no container est√° l√°. Lembrando que, a forma que voc√™ escolher para mapear os dados pode depender completamente de seu contexto e sua necessidade. Ent√£o, chegamos ao fim desta parte da documenta√ß√£o, tudo o que foi mostrado at√© √© um guia b√°sico de como realizar a utiliza√ß√£o do Docker, n√£o deixe de conferir a documenta√ß√£o no site oficial e tamb√©m de fazer testes para ir aprendendo mais! "],
["docker-cheat-sheet.html", "3 Docker Cheat Sheet üìö", " 3 Docker Cheat Sheet üìö Recomenda-se que esta p√°gina seja utilizada para consulta, trazendo ao leitor uma forma simples e direta de consultar comandos do Docker CLI que lhe podem ser √∫teis. Listando os containers ativos: docker ps Listando todos os containers - (Independente do status): docker ps -a Listando todas as imagens: docker images Executando um container: docker run Executando um container - (Com terminal interativo): docker run -ti debian /bin/bash Executando um container como daemon: docker run -d Saindo do shell de container sem finaliza-lo: CTRL + p + q Finalizando um container (Quando conectado em seu shell): CTRL + d Acessar o entrypoint de um container em execu√ß√£o: docker attach CONTAINER_ID Criando o container: docker create centos Parando um container: docker stop CONTAINER_ID Iniciando um container: docker start CONTAINER_ID Pausando um container: docker pause CONTAINER_ID Despausando um container: docker unpause CONTAINER_ID Verificando a quantidade de recursos utilizados pelo container: docker stats CONTAINER_ID Verificando os processos de um container: docker top CONTAINER_ID Visualizando os logs: docker logs CONTAINER_ID Removendo container desligado: docker rm CONTAINER_ID Removendo container em execu√ß√£o: docker rm -f CONTAINER_ID Verificando todas as informa√ß√µes de um container: docker inspect CONTAINER_ID Nomeando container no momento da execu√ß√£o: docker run -ti --name teste debian Verificando informa√ß√µes de mem√≥ria de um container: docker inspect CONTAINER_ID | grep -i mem Limitando mem√≥ria RAM na execu√ß√£o do container (512 MB neste caso): docker run -ti --memory 512m --name limited_mem debian Alterando quantidade de mem√≥ria de um container j√° existente (256 MB neste caso): docker update CONTAINER_ID --memory 256m Limitando CPU de um container no momento da execu√ß√£o (Neste caso propor√ß√£o de 1024): docker run -ti --cpu-shares 1024 --name container1 debian Alterando limite de CPU em container em execu√ß√£o (Neste caso propor√ß√£o de 512): docker update CONTAINER_ID --cpu-shares 512 Criando volume: docker run -ti -v /volume /bin/bash Mapeando volume: docker run -ti -v /path/to/volume_dir:/volume debian Verificando informa√ß√µes de volume: docker inspect -f {{.Mounts}} CONTAINER_ID Criando container data-only: docker create -v /data --name dbDados centos Criando container de banco de dados (Postgres) que utiliza o data-only: docker run -d -p 5432:5432 --name pgsql1 --volumes-from dbdados -e POSTGRESQL_USER=docker -e POSTGRESQL_PASS=docker -e POSTGRESQL_DB=docker kamui/postgresql Fazendo build de um Dockerfile que est√° no diret√≥rio atual: docker build -t INSTITUICAO/NOME_DA_IMAGEM:VERSAO . Definindo DNS do container na execu√ß√£o: docker run -ti --dns ENDERECO_DNS debian Criando link entre containers (Conex√£o entre containers): docker run -ti --link container1 --name container2 debian Abrindo porta do container na execu√ß√£o: docker run -ti --expose PORTA debian Definindo um MAC Address espec√≠fico para um container na execu√ß√£o: docker run -ti --mac-address 12:34:56:b0:6b:61 debian Definindo a porta do container que ser√° publicada: docker run -d -p PORTA_HOST:PORTA_CONTAINER debian "],
["exemplos-de-uso.html", "4 Exemplos de uso 4.1 Postgres 4.2 Postgres + PostGIS 4.3 pgAdmin 4.4 Aplica√ß√£o", " 4 Exemplos de uso Este cap√≠tulo apresenta exemplos de utiliza√ß√£o do Docker para a configura√ß√£o e utiliza√ß√£o de diferentes ferramentas. Os exemplos apresentados neste cap√≠tulo utilizam imagens recuperadas do registry Dockerhub. Boa parte dessas imagens oficiais, ou seja, distribu√≠das pelo grupo, organiza√ß√£o ou institui√ß√£o que cria a ferramenta. Aproveite os exemplos para ver o qu√£o simples √© o compartilhamento de imagens via registry e tamb√©m, o qu√£o simples √© implantar diferentes servi√ßos com o Docker. N√£o √© necess√°rio diversos arquivos de configura√ß√£o! N√£o deixe de conferir a p√°gina de cada imagem no Dockerhub para verificar todas as op√ß√µes dispon√≠veis. 4.1 Postgres Vamos criar um container que possui um banco de dados Postgres e fa√ßa a disponibiliza√ß√£o desse para uso. Para come√ßar vamos utilizar o comando docker pull, que baixa a imagem do registry, neste caso, do Dockerhub e salva em sua lista de imagens. docker pull postgres # Imagem oficial A imagem j√° est√° em sua m√°quina, agora vamos iniciar o servi√ßo docker run --name postgresbd -e POSTGRES_PASSWORD=123@abc -p 5432:5432 -d postgres O par√¢metro -e √© utilizado para definir vari√°veis de ambiente e o -p para definir o direcionamento de porta a ser feito, neste caso, o container recebe na porta 5432 e encaminha para a porta 5432 do servi√ßo que est√° sendo executado. Pronto! O servi√ßo do banco de dados j√° est√° sendo executado, voc√™ pode consultar o container executando atrav√©s do comando docker ps. Para se conectar ao banco voc√™ pode utilizar as seguintes informa√ß√µes Endere√ßo: 127.0.0.1 Porta: 5432 Usu√°rio: postgres Senha: 123@abc A imagem utilizada neste exemplo √© oficial. 4.2 Postgres + PostGIS O Postgres possui uma extens√£o para trabalhar dados geoespaciais, com o Docker a utiliza√ß√£o deste √© muito simples. Atrav√©s de uma imagem disponibilizada por um usu√°rio do Dockerhub, todas as configura√ß√µes deste servi√ßo j√° s√£o feitas. Vejamos como utiliza-lo. Vamos baixar a imagem docker pull kartoza/postgis Ap√≥s baixar a imagem, basta inicializar o container da imagem baixada. docker run --name postgis -p 25432:5432 -d -t kartoza/postgis 4.3 pgAdmin Para acessar os servi√ßos de bancos de dados criados anteriormente, pode-se utilizar um container com um pgAdmin. Vamos come√ßar baixado a vers√£o mais recente desta imagem, para isto, no momento do download a TAG que normalmente indica a vers√£o ser√° passada. docker pull dpage/pgadmin4:latest Agora, vamos executar docker run -p 8080:80 \\ -e &quot;PGADMIN_DEFAULT_EMAIL=email@email.com&quot; \\ -e &quot;PGADMIN_DEFAULT_PASSWORD=1234.&quot; \\ -d dpage/pgadmin4:latest Pronto! Agora se voc√™ acessar 127.0.0.1:8080 Para entrar, utilize as credenciais definidas nas vari√°veis de ambiente no momento que o container foi criada. 4.4 Aplica√ß√£o Nesta subse√ß√£o, vamos inserir uma aplica√ß√£o Python e Flask dentro de um container. Para isto, inicialmente fa√ßamos a cria√ß√£o do arquivo app.py, neste o conte√∫do abaixo √© inserido. from flask import Flask, escape, request app = Flask(__name__) @app.route(&#39;/&#39;) def ola_no_container(): nome = request.args.get(&quot;nome&quot;) return f&quot;Ol√°, {escape(nome)}! Estou dentro de um container!&quot; if __name__ == &#39;__main__&#39;: app.run(debug=True, host=&#39;0.0.0.0&#39;) √â poss√≠vel perceber na listagem de c√≥digo acima que esta aplica√ß√£o b√°sicamente inicia um servidor atrav√©s do Flask e este recebe requisi√ß√µes HTTP que podem conter um par√¢metro nome na requisi√ß√£o, e o conte√∫do dessa par√¢metro passado pelo usu√°rio √© exibido no retorno do servidor. Bem, agora fa√ßamos a cria√ß√£o de um Dockerfile. Vamos utilizar o container oficial de Python em sua vers√£o 3. Neste Dockerfile especificamos tamb√©m que um comando RUN deve ser executado, para executar o pip para instalar o Flask, al√©m de copiar o arquivo app.py para dentro do container. Por fim √© especificado que o ENTRYPOINT, ou seja, o comando principal do container ser√° o python e ele recebe como par√¢metro o nome do arquivo que ele executa (app.py). FROM python:3 # O container, no momento da execu√ß√£o, &#39;escuta&#39; a porta 5000 EXPOSE 5000 COPY app.py ./ RUN pip install Flask # Argumentos para o entrypoint CMD [ &quot;./app.py&quot; ] ENTRYPOINT [ &quot;python&quot; ] Agora execute o docker build para criar a imagem. # Build docker build -t &quot;flaskapp:0.1&quot; . Com a imagem criada, vamos iniciar o container. # Execu√ß√£o docker run -d -p 5000:5000 flaskapp:0.1 Agora sim! V√° at√© seu navegador e acesse o endere√ßo 127.0.0.1:5000 Voc√™ pode editar a URL de requisi√ß√£o e inserir seu nome, por exemplo: http://127.0.0.1:5000?nome=Julia "],
["referencias.html", "Refer√™ncias", " Refer√™ncias "]
]
